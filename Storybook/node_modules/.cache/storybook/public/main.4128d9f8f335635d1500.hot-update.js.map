{"version":3,"file":"main.4128d9f8f335635d1500.hot-update.js","sources":["webpack:///./stories/Ubung6/Page6Kalligraphie.js"],"sourcesContent":["export const createPage6Kalligraphie = ({\n}) => {\n  const article = document.createElement('article');\n\n  const section = `\n  <!DOCTYPE html>\n  <html>\n  <head>\n\t  <title> Kalligraphie-Editor</title>\n\t  <meta charset=\"UTF-8\">\n\t  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\t  \n  </head>\n  \n  <body id=\"body\">\n  <h1>Achtung diese Story funktioniert in Storybook leider nur unter Chrome und ben√∂tigt einen direkten Reload auf dieser Seite. Bei der Verwendung von Firefox, muss die Webseite direkt aufgerufen werden (<a href=https://www.google.de>Hier</a>)</h1>\n\t  <div>\n\t  <svg xmlns=\"http://www.w3.org/2000/svg\"\n\t\t  viewBox=\"0 0 1000 600\"\n\t\t  onload=\"makeDrawable(evt)\">\n\t\t  <rect x=\"0\" y=\"0\" width=\"1000\" height=\"600\" fill=\"#DDDDDD\">\n\t  </svg>\n\t  \n\t  </div>\n\t  \n  </body>\n  \n  <script>\n\t  \n\t  \n\t  var polyPoints = [];\n\t  \n\t  function makeDrawable(evt)\n\t  {\n\t\t  var svg = evt.target;\n\t\t  var currentpoly;\n\t\t  \n\t\t  var myInterval;\n\t\t  \n\t\t  \n\t\t  var lastpoint;\n\t\t  svg.addEventListener('mousedown', startDraw);\n\t\t  svg.addEventListener('mousemove', Draw);\n\t\t  svg.addEventListener('mouseup', endDraw);\n\t\t  svg.addEventListener('mouseleave', endDraw);\n\t  \n\t\t  function startDraw(evt)\n\t\t  {\n\t\t\t  currentpoly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n\t\t\t  svg.appendChild(currentpoly);\n\t\t\t  coord = getMousePosition(evt);\n\t\t\t  lastpoint = coord;\n\t\t\t  polyPoints.push(coord.ToString());\n\t\t\t  polyPoints.push(coord.ToString());\n\t\t\t  currentpoly.setAttribute(\"points\",coord.ToString());\n\t\t\t  currentpoly.setAttribute(\"stroke-width\",\"1\");\n\t\t\t  currentpoly.setAttribute(\"stroke\",\"black\");\n\t\t\t  currentpoly.setAttribute(\"fill\",\"#333333\");\n\t\t\t  console.log(coord);\n\t\t\t  myInterval = setInterval(function(){doInterval(evt)}, 50);\n\t\t  }\n\t\t  var intevt;\n\t\t  function Draw(evt)\n\t\t  {\n\t\t\t  if(currentpoly)\n\t\t\t  {\n\t\t\t\t  intevt = evt;\n\t\t\t  }\n  \n\t\t  }\t\n\t\t  function doInterval(evt)\n\t\t  {\n\t\t\t  if(intevt)\n\t\t\t  {\n\t\t\t\t  coord = getMousePosition(intevt);\n\t\t\t\t  points = PointsToString(coord,lastpoint);\n\t\t\t\t\t  \n\t\t\t\t  polyPoints.splice(polyPoints.length/2,0,points[0],points[1]);\n\t\t\t\t  currentpoly.setAttribute(\"points\", polyPoints);\n\t\t\t\t  console.log(coord)\n\t\t\t\t\t  \n\t\t\t\t\t  \n\t\t\t\t  lastpoint = coord;\n\t\t\t  }\n\t\t  }\n\t\t  \n\t\t  function endDraw(evt)\n\t\t  {\n\t\t\t  intevt = null; \n\t\t\t  clearInterval(myInterval);\n\t\t\t  currentpoly = null;\n\t\t\t  polyPoints = [];\n\t\t\t  lastpoint = null;\n\t\t  }\n\t\t  \n\t\t  function getMousePosition(evt)\n\t\t  {\n\t\t\t  const CTM = document.querySelector('svg').getScreenCTM();\n\t\t\t  return new Point(\n\t\t\t\t  (evt.clientX - CTM.e)/ CTM.a,\n\t\t\t\t  (evt.clientY - CTM.f)/ CTM.d\n\t\t\t  );\n\t\t  }\n\t  }\n\t  \n\t  function setLineFromPoints(line,po1,po2)\n\t  {\n\t\t  line.setAttribute(\"x1\",po1.getAttribute(\"cx\"));\n\t\t  line.setAttribute(\"y1\",po1.getAttribute(\"cy\"));\n\t\t  line.setAttribute(\"x2\",po2.getAttribute(\"cx\"));\n\t\t  line.setAttribute(\"y2\",po2.getAttribute(\"cy\"));\n\t  }\n\t  \n  \n\t  function PointsToString(p1,p2)\n\t  {\n\t\t  DistanceVek = p1.sub(p2);\n\t\t  console.log( DistanceVek,p1,p2);\n\t\t  \n\t\t  \n\t\t  ortho = DistanceVek.getOrthogonale().kehrwert().mul(7);\n\t\t  \n\t\t  \n\t\t  return [p1.plus(ortho).ToString(), p1.plus(ortho.NegativVektor()).ToString()];\n\t\t  \n\t  }\n  \n\t  \n\t  class Point \n\t  {\n\t\t  constructor(x, y) {\n\t\t\t  this.x = x;\n\t\t\t  this.y = y;\n\t\t  }\n  \n\t\t  laenge(a) {\n\t\t\t  if(a === undefined)\n\t\t\t  {\n\t\t\t\t  const dx = this.x;\n\t\t\t\t  const dy = this.y;\n\t\t\t\t  return Math.sqrt((dx*dx) + (dy*dy));\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t\t  const dx = a.x - this.x;\n\t\t\t\t  const dy = a.y - this.y;\n\t\t\t\t  return Math.sqrt((dx*dx) + (dy*dy));\n\t\t\t  }\n\t\t\t  \n\t\t  }\n\t\t  getOrthogonale(p = this)\n\t\t  {\n\t\t\t  return new Point(-p.y,p.x)\n\t\t  }\n\t\t  ToString(p = this)\n\t\t  {\n\t\t\t  return p.x + \",\" + p.y + \" \";\n\t\t  }\n\t\t  NegativVektor(p = this)\n\t\t  {\n\t\t\t  return new Point(-p.x,-p.y);\n\t\t  }\n\t\t  mul(f)\n\t\t  {\n\t\t\t  return new Point(this.x*f,this.y*f);\n\t\t  }\n\t\t  plus(b)\n\t\t  {\n\t\t\t  return new Point(this.x+b.x,this.y+b.y);\n\t\t  }\n\t\t  sub(b)\n\t\t  {\n\t\t\t  return new Point(this.x-b.x,this.y-b.y);\n\t\t  }\n\t\t  kehrwert()\n\t\t  {\n\t\t\t  var dx = 1/this.x\n\t\t\t  var dy = 1/this.y\n\t\t\t  if(dx === Infinity || dx === -Infinity)\n\t\t\t\t  dx = this.x\n\t\t\t  if(dy === Infinity || dy === -Infinity)\n\t\t\t\t  dy = this.y\n\t\t\t  \n\t\t\t  return new Point(dx,dy);\n\t\t  }\n\t  }\n\t  \n\t  \n\t  \n  </script>\n  \n  </html>\n  \n  \n\n\n\n`;\n\n  article.insertAdjacentHTML('beforeend', section);\n\n  return section;\n};\n"],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AAAA;AAEA;AAmMA;AAEA;AACA;;;;A","sourceRoot":""}